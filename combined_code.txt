File: frontend/src/api\api.js
// frontend/src/api/api.js
import axios from 'axios';

const API_BASE_URL = 'http://localhost:8000'; // Backend URL

export const registerUser = async (username, email, password) => {
  try {
    const response = await axios.post(`${API_BASE_URL}/register`, {
      username,
      email,
      password,
    });
    return response.data;
  } catch (error) {
    throw new Error(error.response?.data?.detail || 'Registration failed');
  }
};

export const loginUser = async (username, password) => {
  try {
    const response = await axios.post(`${API_BASE_URL}/login`, {
      username,
      password,
    });
    return response.data;
  } catch (error) {
    throw new Error(error.response?.data?.detail || 'Login failed');
  }
};


File: frontend/src/api\userService.js
// frontend/src/api/userService.js
const AWS = require("aws-sdk");
const bcrypt = require("bcrypt");

AWS.config.update({ region: "ap-east-1" }); // Set your AWS region
const dynamoDB = new AWS.DynamoDB.DocumentClient();
const USER_PASSWORDS_TABLE = "user_passwords";
const SALT_ROUNDS = 10;

// Check if a user exists by username
async function checkUserExists(username) {
  const params = {
    TableName: USER_PASSWORDS_TABLE,
    Key: {
      username, // Only the Partition Key
    },
  };

  console.log("DynamoDB GetItem Params:", params); // Log parameters

  try {
    const result = await dynamoDB.get(params).promise();
    console.log("DynamoDB GetItem Result:", result); // Log result
    return !!result.Item; // Returns true if the user exists
  } catch (error) {
    console.error("Error in checkUserExists:", error); // Log error details
    throw new Error("Failed to check user existence");
  }
}

// Register a new user
async function registerUser(username, email, password) {
  const userExists = await checkUserExists(username);
  if (userExists) {
    throw new Error("Username already exists");
  }

  const passwordHash = await bcrypt.hash(password, SALT_ROUNDS);

  const params = {
    TableName: USER_PASSWORDS_TABLE,
    Item: {
      username,                // Partition Key
      email,                   // Additional attribute
      password: passwordHash,  // Hashed password
    },
  };

  await dynamoDB.put(params).promise();
  return { success: true, message: "User registered successfully" };
}

// Verify user login
async function verifyUser(username, password) {
  const params = {
    TableName: USER_PASSWORDS_TABLE,
    Key: {
      username, // Only the Partition Key
    },
  };

  const result = await dynamoDB.get(params).promise();

  if (!result.Item) {
    throw new Error("Invalid username or password");
  }

  const passwordMatch = await bcrypt.compare(password, result.Item.password);

  if (!passwordMatch) {
    throw new Error("Invalid password");
  }

  return { success: true, message: "Login successful" };
}

module.exports = {
  registerUser,
  verifyUser,
};


File: frontend/src/components\GoBoard.js
// frontend/src/components/GoBoard.js
import React from "react";
import "./GoBoard.css";

/**
 * GoBoard
 * - NxN (default 19x19)
 * - star points
 * - Stones on intersections
 * - showScoring + scoringData => highlight dead stones, territory
 * - isReplaying => disable onCellClick if needed
 */
function GoBoard({
  boardSize = 19,
  board = [],
  currentPlayer = "black",
  isReplaying = false,
  onCellClick,
  showScoring = false,
  scoringData = {},
}) {
  const starPoints = [
    [3, 3], [3, 9], [3, 15],
    [9, 3], [9, 9], [9, 15],
    [15, 3], [15, 9], [15, 15],
  ];

  const cells = [];
  for (let x = 0; x < boardSize; x++) {
    for (let y = 0; y < boardSize; y++) {
      const stone = board[x]?.[y];
      const topPos = x * 30;
      const leftPos = y * 30;

      // Check if this stone is marked dead
      let isDead = false;
      if (showScoring && scoringData.deadStones) {
        isDead = scoringData.deadStones.some(
          ([dx, dy]) => dx === x && dy === y
        );
      }

      // If territory is given
      let territoryOwner = null;
      if (showScoring && scoringData.territory) {
        const found = scoringData.territory.find(
          (t) => t.x === x && t.y === y
        );
        if (found) {
          territoryOwner = found.owner; // "black" or "white"
        }
      }

      cells.push(
        <div
          key={`${x}-${y}`}
          className="board-cell"
          style={{ top: `${topPos}px`, left: `${leftPos}px` }}
          onClick={() => {
            if (!isReplaying && onCellClick) {
              onCellClick(x, y);
            }
          }}
        >
          {/* If there's a stone */}
          {stone === "black" && (
            <div className={`stone black ${isDead ? "dead" : ""}`} />
          )}
          {stone === "white" && (
            <div className={`stone white ${isDead ? "dead" : ""}`} />
          )}

          {/* star point */}
          {starPoints.some(([sx, sy]) => sx === x && sy === y) && (
            <div className="star-point" />
          )}

          {/* territory marker */}
          {territoryOwner && (
            <div
              className="territory-marker"
              style={{
                backgroundColor:
                  territoryOwner === "black"
                    ? "rgba(0,0,0,0.3)"
                    : "rgba(255,255,255,0.7)",
              }}
            />
          )}
        </div>
      );
    }
  }

  return (
    <div className="go-board-outer">
      <div className="go-board-wrapper">
        <div className="board-grid">{cells}</div>
      </div>
    </div>
  );
}

export default GoBoard;


File: frontend/src/components\Navbar.jsx
// frontend/src/components/Navbar.jsx
import React from 'react';
import { AppBar, Toolbar, Typography, Button, Box } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { isAuthenticated, login, logout } from '../services/auth';

function Navbar() {
  const navigate = useNavigate();

  const handleLogin = async () => {
    const username = prompt('Enter your username:');
    const password = prompt('Enter your password:');
    try {
      await login(username, password);
      localStorage.setItem("username", username);
      alert('Login successful!');
      navigate('/profile');
    } catch (error) {
      alert(`Login failed: ${error.message}`);
    }
  };

  const handleLogout = () => {
    localStorage.removeItem("username");
    logout();
    alert('Logged out successfully!');
    navigate('/');
  };

  return (
    <AppBar position="static">
      <Toolbar>
        <Typography
          variant="h6"
          sx={{ flexGrow: 1, cursor: 'pointer' }}
          onClick={() => navigate('/')}
        >
          Magic Weiqi
        </Typography>
        {isAuthenticated() ? (
          <Box>
            <Button color="inherit" onClick={() => navigate('/lobby')}>
              Lobby
            </Button>
            <Button color="inherit" onClick={() => navigate('/profile')}>
              Profile
            </Button>
            <Button color="inherit" onClick={handleLogout}>
              Logout
            </Button>
          </Box>
        ) : (
          <Box>
            <Button color="inherit" onClick={handleLogin}>
              Login
            </Button>
            <Button color="inherit" onClick={() => navigate('/register')}>
              Register
            </Button>
          </Box>
        )}
      </Toolbar>
    </AppBar>
  );
}

export default Navbar;


File: frontend/src/components\ProtectedRoute.jsx
// frontend/src/components/ProtectedRoute.jsx
import React from "react";
import { Navigate } from "react-router-dom";
import { isAuthenticated } from "../authUtils";

function ProtectedRoute({ children }) {
  return isAuthenticated() ? children : <Navigate to="/" />;
}

export default ProtectedRoute;


File: frontend/src/components\RoomCreationModal.jsx
// frontend/src/components/RoomCreationModal.jsx
import React, { useState } from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
} from "@mui/material";

function RoomCreationModal({ open, onClose, onCreate }) {
  const [eloMin, setEloMin] = useState(0);
  const [eloMax, setEloMax] = useState(9999);
  const [whoIsBlack, setWhoIsBlack] = useState("creator"); // or "opponent" or "random"
  const [timeRule, setTimeRule] = useState("absolute");    // or "byoyomi"
  const [mainTime, setMainTime] = useState(300);
  const [byoYomiPeriods, setByoYomiPeriods] = useState(3);
  const [byoYomiTime, setByoYomiTime] = useState(30);

  const handleCreate = () => {
    onCreate({
      eloMin,
      eloMax,
      whoIsBlack,
      timeRule,
      mainTime,
      byoYomiPeriods,
      byoYomiTime,
      boardSize: 19,
      handicap: 0, // 分先
    });
  };

  return (
    <Dialog open={open} onClose={onClose}>
      <DialogTitle>Create Room</DialogTitle>
      <DialogContent>
        <TextField
          label="ELO Min"
          type="number"
          fullWidth
          margin="dense"
          value={eloMin}
          onChange={(e) => setEloMin(Number(e.target.value))}
        />
        <TextField
          label="ELO Max"
          type="number"
          fullWidth
          margin="dense"
          value={eloMax}
          onChange={(e) => setEloMax(Number(e.target.value))}
        />

        <FormControl fullWidth margin="dense">
          <InputLabel>Who is Black</InputLabel>
          <Select
            value={whoIsBlack}
            onChange={(e) => setWhoIsBlack(e.target.value)}
          >
            <MenuItem value="creator">Me (Creator)</MenuItem>
            <MenuItem value="opponent">Opponent</MenuItem>
            <MenuItem value="random">Random</MenuItem>
          </Select>
        </FormControl>

        <FormControl fullWidth margin="dense">
          <InputLabel>Time Rule</InputLabel>
          <Select
            value={timeRule}
            onChange={(e) => setTimeRule(e.target.value)}
          >
            <MenuItem value="absolute">Absolute</MenuItem>
            <MenuItem value="byoyomi">Byo-yomi</MenuItem>
          </Select>
        </FormControl>

        {timeRule === "absolute" ? (
          <TextField
            label="Main Time (sec)"
            type="number"
            fullWidth
            margin="dense"
            value={mainTime}
            onChange={(e) => setMainTime(Number(e.target.value))}
          />
        ) : (
          <>
            <TextField
              label="Main Time (sec)"
              type="number"
              fullWidth
              margin="dense"
              value={mainTime}
              onChange={(e) => setMainTime(Number(e.target.value))}
            />
            <TextField
              label="Byo-yomi Time (sec)"
              type="number"
              fullWidth
              margin="dense"
              value={byoYomiTime}
              onChange={(e) => setByoYomiTime(Number(e.target.value))}
            />
            <TextField
              label="Byo-yomi Periods"
              type="number"
              fullWidth
              margin="dense"
              value={byoYomiPeriods}
              onChange={(e) => setByoYomiPeriods(Number(e.target.value))}
            />
          </>
        )}
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>Cancel</Button>
        <Button onClick={handleCreate} variant="contained">
          Create
        </Button>
      </DialogActions>
    </Dialog>
  );
}

export default RoomCreationModal;


File: frontend/src/components\ScoringPanel.js
// frontend/src/components/ScoringPanel.js
import React from "react";
import { Button, Typography } from "@mui/material";

function ScoringPanel({
  currentPlayer,
  blackScore,
  whiteScore,
  onConfirmScoring,
  onCancelScoring,
}) {
  return (
    <div style={{ padding: 10 }}>
      <Typography variant="h6">Scoring Mode</Typography>
      <Typography>Black Score: {blackScore}</Typography>
      <Typography>White Score: {whiteScore}</Typography>
      <div style={{ marginTop: 8 }}>
        <Button
          variant="contained"
          color="primary"
          onClick={onConfirmScoring}
          style={{ marginRight: 8 }}
        >
          Ready / Confirm
        </Button>
        <Button variant="outlined" onClick={onCancelScoring}>
          Cancel
        </Button>
      </div>
    </div>
  );
}

export default ScoringPanel;


File: frontend/src/config\config.js
// frontend/src/config/config.js
export const API_BASE_URL = "http://127.0.0.1:8000/api/v1";


File: frontend/src/pages\Game.jsx
// src/pages/Game.jsx
import React from "react";

function Game() {
  return <h1>Game Page</h1>;
}

export default Game;


File: frontend/src/pages\GoGamePage.js
// frontend/src/pages/GoGamePage.js
import React, { useState, useEffect, useRef } from "react";
import {
  Grid,
  Paper,
  Typography,
  Button,
  Dialog,
  DialogTitle,
  DialogActions,
} from "@mui/material";
import axios from "axios";
import GoBoard from "../components/GoBoard";
import { API_BASE_URL } from "../config/config";
import ScoringPanel from "../components/ScoringPanel";

function GoGamePage() {
  const [matchId, setMatchId] = useState(null);
  const [board, setBoard] = useState([]);
  const [currentPlayer, setCurrentPlayer] = useState("black");
  const [passes, setPasses] = useState(0);
  const [captured, setCaptured] = useState({ black: 0, white: 0 });
  const [historyLength, setHistoryLength] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [winner, setWinner] = useState(null);

  const [players, setPlayers] = useState([]);
  const [blackCards, setBlackCards] = useState([]);
  const [whiteCards, setWhiteCards] = useState([]);

  const [errorMessage, setErrorMessage] = useState("");
  const [resignMessage, setResignMessage] = useState("");

  const [history, setHistory] = useState([]);
  const [currentStep, setCurrentStep] = useState(0);

  const [blackTime, setBlackTime] = useState(300);
  const [whiteTime, setWhiteTime] = useState(300);
  const timerRef = useRef(null);

  const [confirmNewGameOpen, setConfirmNewGameOpen] = useState(false);
  const [confirmResignOpen, setConfirmResignOpen] = useState(false);

  const [sgfData, setSgfData] = useState("");
  const [username, setUsername] = useState("");

  // --- 数子(Scoring)相关 ---
  const [scoringMode, setScoringMode] = useState(false);
  const [scoringData, setScoringData] = useState({
    deadStones: [],
    territory: [],
    blackScore: 0,
    whiteScore: 0,
  });
  const [blackReady, setBlackReady] = useState(false);
  const [whiteReady, setWhiteReady] = useState(false);

  // On mount, create a match
  useEffect(() => {
    const localUser = localStorage.getItem("username") || "";
    setUsername(localUser);
    createMatch();
    // eslint-disable-next-line
  }, []);

  // Create new match
  const createMatch = () => {
    const token = localStorage.getItem("token");
    axios
      .post(
        `${API_BASE_URL}/matches`,
        { board_size: 19 },
        {
          headers: { Authorization: `Bearer ${token}` },
        }
      )
      .then((res) => {
        setMatchId(res.data.match_id);
        setBoard(res.data.board);
        setCurrentPlayer(res.data.current_player);
        setPasses(res.data.passes);
        setCaptured(res.data.captured || { black: 0, white: 0 });
        setHistoryLength(res.data.history_length);
        setGameOver(res.data.game_over);
        setWinner(res.data.winner);

        const firstSnapshot = {
          board: res.data.board,
          currentPlayer: res.data.current_player,
          passes: res.data.passes,
          captured: res.data.captured || { black: 0, white: 0 },
          historyLength: res.data.history_length,
          gameOver: res.data.game_over,
          winner: res.data.winner,
        };
        setHistory([firstSnapshot]);
        setCurrentStep(0);

        // Reset timers
        setBlackTime(300);
        setWhiteTime(300);
      })
      .catch((err) => {
        console.error("Failed to create match:", err);
        setErrorMessage("Failed to create or load a match.");
      });
  };

  // Fetch players & cards after matchId is set
  useEffect(() => {
    if (!matchId) return;
    const token = localStorage.getItem("token");
    axios
      .get(`${API_BASE_URL}/matches/${matchId}/players`, {
        headers: { Authorization: `Bearer ${token}` },
      })
      .then((res) => {
        setPlayers(res.data.players || []);
        setBlackCards(res.data.black_cards || []);
        setWhiteCards(res.data.white_cards || []);
      })
      .catch((err) => {
        console.error("Failed to fetch player/cards:", err);
        setErrorMessage("Failed to load player data.");
      });
  }, [matchId]);

  // Timer effect
  useEffect(() => {
    // If game is over or user is in "Past" step or scoring mode => no ticking
    if (gameOver || currentStep < history.length - 1 || scoringMode) {
      clearInterval(timerRef.current);
      return;
    }
    clearInterval(timerRef.current);
    timerRef.current = setInterval(() => {
      if (currentPlayer === "black") {
        setBlackTime((prev) => {
          if (prev <= 1) {
            clearInterval(timerRef.current);
            alert("Black time is up!");
            return 0;
          }
          return prev - 1;
        });
      } else {
        setWhiteTime((prev) => {
          if (prev <= 1) {
            clearInterval(timerRef.current);
            alert("White time is up!");
            return 0;
          }
          return prev - 1;
        });
      }
    }, 1000);
    return () => clearInterval(timerRef.current);
  }, [currentPlayer, gameOver, currentStep, history, scoringMode]);

  // Handle board click => place stone or mark dead
  const handleMove = (x, y) => {
    if (scoringMode) {
      // Mark dead stone in scoring mode
      markDeadStone(x, y);
      return;
    }
    if (currentStep < history.length - 1) {
      setErrorMessage("You are replaying history, cannot place moves now.");
      return;
    }
    if (!matchId || gameOver) {
      setErrorMessage("Game is over or invalid match.");
      return;
    }
    const token = localStorage.getItem("token");
    axios
      .post(
        `${API_BASE_URL}/matches/${matchId}/move`,
        { x, y },
        { headers: { Authorization: `Bearer ${token}` } }
      )
      .then((res) => {
        setBoard(res.data.board);
        setCurrentPlayer(res.data.current_player);
        setPasses(res.data.passes);
        setCaptured(res.data.captured || { black: 0, white: 0 });
        setHistoryLength(res.data.history_length);
        setGameOver(res.data.game_over);
        setWinner(res.data.winner);
        setErrorMessage("");

        const newSnapshot = {
          board: res.data.board,
          currentPlayer: res.data.current_player,
          passes: res.data.passes,
          captured: res.data.captured || { black: 0, white: 0 },
          historyLength: res.data.history_length,
          gameOver: res.data.game_over,
          winner: res.data.winner,
        };
        const newHistory = [...history.slice(0, currentStep + 1), newSnapshot];
        setHistory(newHistory);
        setCurrentStep(newHistory.length - 1);
        setResignMessage("");
      })
      .catch((err) => {
        console.error("Error making a move:", err);
        setErrorMessage(err.response?.data?.detail || "Failed to make a move.");
      });
  };

  // Pass
  const handlePass = () => {
    if (scoringMode) {
      setErrorMessage("Cannot pass in scoring mode.");
      return;
    }
    if (currentStep < history.length - 1) {
      setErrorMessage("You are replaying history, cannot pass now.");
      return;
    }
    if (!matchId || gameOver) {
      setErrorMessage("Game is over or invalid match.");
      return;
    }
    const token = localStorage.getItem("token");
    axios
      .post(
        `${API_BASE_URL}/matches/${matchId}/move`,
        { x: null, y: null },
        { headers: { Authorization: `Bearer ${token}` } }
      )
      .then((res) => {
        setBoard(res.data.board);
        setCurrentPlayer(res.data.current_player);
        setPasses(res.data.passes);
        setCaptured(res.data.captured || { black: 0, white: 0 });
        setHistoryLength(res.data.history_length);
        setGameOver(res.data.game_over);
        setWinner(res.data.winner);
        setErrorMessage("");

        const newSnapshot = {
          board: res.data.board,
          currentPlayer: res.data.current_player,
          passes: res.data.passes,
          captured: res.data.captured || { black: 0, white: 0 },
          historyLength: res.data.history_length,
          gameOver: res.data.game_over,
          winner: res.data.winner,
        };
        const newHistory = [...history.slice(0, currentStep + 1), newSnapshot];
        setHistory(newHistory);
        setCurrentStep(newHistory.length - 1);
        setResignMessage("");
      })
      .catch((err) => {
        console.error("Error passing:", err);
        setErrorMessage(err.response?.data?.detail || "Failed to pass.");
      });
  };

  // Resign
  const handleResign = () => {
    if (scoringMode) {
      setErrorMessage("Cannot resign in scoring mode.");
      return;
    }
    if (currentStep < history.length - 1) {
      setErrorMessage("You are replaying history, cannot resign now.");
      return;
    }
    if (!matchId || gameOver) {
      setErrorMessage("Game is over or invalid match.");
      return;
    }
    const token = localStorage.getItem("token");
    axios
      .post(
        `${API_BASE_URL}/matches/${matchId}/resign`,
        { player: currentPlayer },
        { headers: { Authorization: `Bearer ${token}` } }
      )
      .then((res) => {
        setBoard(res.data.board);
        setResignMessage(res.data.message);
        setPasses(res.data.passes);
        setCaptured(res.data.captured || { black: 0, white: 0 });
        setHistoryLength(res.data.history_length);
        setGameOver(res.data.game_over);
        setWinner(res.data.winner);
        setErrorMessage("");

        const newSnapshot = {
          board: res.data.board,
          currentPlayer,
          passes: res.data.passes,
          captured: res.data.captured || { black: 0, white: 0 },
          historyLength: res.data.history_length,
          gameOver: res.data.game_over,
          winner: res.data.winner,
        };
        const newHistory = [...history.slice(0, currentStep + 1), newSnapshot];
        setHistory(newHistory);
        setCurrentStep(newHistory.length - 1);
      })
      .catch((err) => {
        console.error("Error resigning:", err);
        setErrorMessage(err.response?.data?.detail || "Failed to resign.");
      });
  };

  // Replay: Prev
  const handlePrev = () => {
    if (currentStep > 0) {
      const newStep = currentStep - 1;
      setCurrentStep(newStep);
      const snap = history[newStep];
      setBoard(snap.board);
      setCurrentPlayer(snap.currentPlayer);
      setPasses(snap.passes);
      setCaptured(snap.captured || { black: 0, white: 0 });
      setHistoryLength(snap.historyLength);
      setGameOver(snap.gameOver);
      setWinner(snap.winner);
      setErrorMessage("");
      setResignMessage("");
    }
  };

  // Replay: Next
  const handleNext = () => {
    if (currentStep < history.length - 1) {
      const newStep = currentStep + 1;
      setCurrentStep(newStep);
      const snap = history[newStep];
      setBoard(snap.board);
      setCurrentPlayer(snap.currentPlayer);
      setPasses(snap.passes);
      setCaptured(snap.captured || { black: 0, white: 0 });
      setHistoryLength(snap.historyLength);
      setGameOver(snap.gameOver);
      setWinner(snap.winner);
      setErrorMessage("");
      setResignMessage("");
    }
  };

  // Request Counting => scoring mode
  const handleRequestCounting = () => {
    if (scoringMode) {
      setErrorMessage("Already in scoring mode.");
      return;
    }
    setScoringMode(true);
    setBlackReady(false);
    setWhiteReady(false);
    setErrorMessage("");
  };

  // Mark dead stone
  const markDeadStone = (x, y) => {
    if (!matchId) return;
    const token = localStorage.getItem("token");
    axios
      .post(
        `${API_BASE_URL}/matches/${matchId}/mark_dead_stone`,
        { x, y },
        { headers: { Authorization: `Bearer ${token}` } }
      )
      .then((res) => {
        setScoringData(res.data.scoring_data);
      })
      .catch((err) => {
        console.error(err);
        setErrorMessage("Failed to mark dead stone.");
      });
  };

  // Confirm scoring
  const handleConfirmScoring = () => {
    if (!matchId) return;
    const token = localStorage.getItem("token");
    // e.g. if both players ready => final scoring
    axios
      .post(`${API_BASE_URL}/matches/${matchId}/confirm_scoring`, {}, {
        headers: { Authorization: `Bearer ${token}` },
      })
      .then((res) => {
        if (res.data.final_scored) {
          setScoringData({
            ...scoringData,
            blackScore: res.data.black_score,
            whiteScore: res.data.white_score,
          });
          setGameOver(true);
          setWinner(res.data.winner);
        }
      })
      .catch((err) => {
        console.error(err);
        setErrorMessage("Confirm scoring failed.");
      });
  };

  // Cancel scoring => revert normal
  const handleCancelScoring = () => {
    setScoringMode(false);
    setBlackReady(false);
    setWhiteReady(false);
    setErrorMessage("");
  };

  // Request Draw
  const handleRequestDraw = () => {
    alert("Request draw (not implemented yet)");
  };

  // Export SGF
  const handleExportSGF = async () => {
    if (!matchId) return;
    try {
      const token = localStorage.getItem("token");
      const res = await axios.get(`${API_BASE_URL}/matches/${matchId}/export_sgf`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      const sgf = res.data.sgf;
      setSgfData(sgf);

      const blob = new Blob([sgf], { type: "application/x-go-sgf" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = `match_${matchId}.sgf`;
      link.click();
      URL.revokeObjectURL(url);
    } catch (err) {
      console.error("Error exporting SGF:", err);
      alert("Failed to export SGF");
    }
  };

  // NewGame dialog
  const handleConfirmNewGame = () => setConfirmNewGameOpen(true);
  const handleCloseNewGameDialog = () => setConfirmNewGameOpen(false);
  const handleNewGameOK = () => {
    setConfirmNewGameOpen(false);
    createMatch();
  };

  // Resign dialog
  const handleConfirmResign = () => setConfirmResignOpen(true);
  const handleCloseResignDialog = () => setConfirmResignOpen(false);
  const handleResignOK = () => {
    setConfirmResignOpen(false);
    handleResign();
  };

  // Player data
  const blackPlayerData = players.find((p) => p.is_black) || {
    player_id: "UnknownBlack",
    elo: "??",
  };
  const whitePlayerData = players.find((p) => !p.is_black) || {
    player_id: "UnknownWhite",
    elo: "??",
  };

  return (
    <div style={{ padding: 16 }}>
      <Grid container spacing={2}>

        {/* Left panel: black info */}
        <Grid item xs={2}>
          <Paper style={{ padding: "8px", marginBottom: "8px" }}>
            <Typography variant="subtitle1" style={{ fontWeight: "bold" }}>
              Opponent (Black)
            </Typography>
            <Typography>Username: {blackPlayerData.player_id}</Typography>
            <Typography>ELO: {blackPlayerData.elo}</Typography>
            <Typography>Time: {blackTime}s</Typography>
            <Typography>Captured: {captured.black}</Typography>

            {blackCards.length > 0 && (
              <>
                <Typography variant="subtitle2" style={{ marginTop: 6 }}>
                  Black Cards
                </Typography>
                {blackCards.map((card) => (
                  <Paper
                    key={card.card_id}
                    style={{ padding: "4px", marginTop: "4px" }}
                    variant="outlined"
                  >
                    <Typography>
                      {card.name} (Cost: {card.cost})
                    </Typography>
                    <Typography variant="body2">{card.description}</Typography>
                  </Paper>
                ))}
              </>
            )}
          </Paper>
        </Grid>

        {/* Center: Board */}
        <Grid item xs={8}>
          <GoBoard
            boardSize={19}
            board={board}
            currentPlayer={currentPlayer}
            isReplaying={currentStep < history.length - 1 || gameOver}
            onCellClick={handleMove}
            showScoring={scoringMode}
            scoringData={scoringData}
          />

          <div style={{ marginTop: 20, textAlign: "center" }}>
            <Button
              onClick={handlePrev}
              disabled={currentStep === 0}
              variant="outlined"
              style={{ margin: 4 }}
            >
              Prev
            </Button>
            <Button
              onClick={handleNext}
              disabled={currentStep === history.length - 1}
              variant="outlined"
              style={{ margin: 4 }}
            >
              Next
            </Button>
            <Button onClick={handlePass} variant="outlined" style={{ margin: 4 }}>
              Pass
            </Button>
            <Button
              onClick={handleConfirmResign}
              variant="outlined"
              color="error"
              style={{ margin: 4 }}
            >
              Resign
            </Button>
            <Button
              onClick={handleRequestCounting}
              variant="outlined"
              style={{ margin: 4 }}
            >
              Request Counting
            </Button>
            <Button
              onClick={handleRequestDraw}
              variant="outlined"
              style={{ margin: 4 }}
            >
              Request Draw
            </Button>
            <Button
              onClick={handleExportSGF}
              variant="outlined"
              style={{ margin: 4 }}
              disabled={!gameOver}
            >
              Export SGF
            </Button>
            <Button
              onClick={handleConfirmNewGame}
              variant="outlined"
              color="secondary"
              style={{ margin: 4 }}
            >
              New Game
            </Button>
          </div>

          {/* Scoring panel (only visible in scoringMode) */}
          {scoringMode && (
            <ScoringPanel
              currentPlayer={currentPlayer}
              blackScore={scoringData.blackScore}
              whiteScore={scoringData.whiteScore}
              onConfirmScoring={handleConfirmScoring}
              onCancelScoring={handleCancelScoring}
            />
          )}

          {/* Errors & messages */}
          {errorMessage && (
            <Typography color="error" style={{ marginTop: 8 }}>
              {errorMessage}
            </Typography>
          )}
          {resignMessage && (
            <Typography color="primary" style={{ marginTop: 8 }}>
              {resignMessage}
            </Typography>
          )}
        </Grid>

        {/* Right panel: white info */}
        <Grid item xs={2}>
          <Paper style={{ padding: "8px", marginBottom: "8px" }}>
            <Typography variant="subtitle1" style={{ fontWeight: "bold" }}>
              Opponent (White)
            </Typography>
            <Typography>Username: {whitePlayerData.player_id}</Typography>
            <Typography>ELO: {whitePlayerData.elo}</Typography>
            <Typography>Time: {whiteTime}s</Typography>
            <Typography>Captured: {captured.white}</Typography>

            {whiteCards.length > 0 && (
              <>
                <Typography variant="subtitle2" style={{ marginTop: 6 }}>
                  White Cards
                </Typography>
                {whiteCards.map((card) => (
                  <Paper
                    key={card.card_id}
                    style={{ padding: "4px", marginTop: "4px" }}
                    variant="outlined"
                  >
                    <Typography>
                      {card.name} (Cost: {card.cost})
                    </Typography>
                    <Typography variant="body2">{card.description}</Typography>
                  </Paper>
                ))}
              </>
            )}
          </Paper>
        </Grid>
      </Grid>

      {/* New Game Dialog */}
      <Dialog open={confirmNewGameOpen} onClose={handleCloseNewGameDialog}>
        <DialogTitle>Start a new game?</DialogTitle>
        <DialogActions>
          <Button onClick={handleCloseNewGameDialog}>Cancel</Button>
          <Button onClick={handleNewGameOK} color="secondary" variant="contained">
            OK
          </Button>
        </DialogActions>
      </Dialog>

      {/* Resign Dialog */}
      <Dialog open={confirmResignOpen} onClose={handleCloseResignDialog}>
        <DialogTitle>Confirm Resign?</DialogTitle>
        <DialogActions>
          <Button onClick={handleCloseResignDialog}>Cancel</Button>
          <Button onClick={handleResignOK} color="error" variant="contained">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    </div>
  );
}

export default GoGamePage;


File: frontend/src/pages\HomePage.js
// frontend/src/pages/HomePage.js
import React, { useState, useEffect } from "react";
import { fetchUserInfo } from "../services/auth";

function HomePage() {
  const [username, setUsername] = useState("");
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  useEffect(() => {
    const fetchUser = async () => {
      try {
        const userInfo = await fetchUserInfo();
        setUsername(userInfo.username);
        setIsLoggedIn(true);
      } catch {
        setIsLoggedIn(false);
      }
    };
    fetchUser();
  }, []);

  return (
    <div>
      <h1>Welcome to Magic Weiqi</h1>
      {isLoggedIn ? (
        <p>You're signed in as {username}</p>
      ) : (
        <p>You're not signed in.</p>
      )}
    </div>
  );
}

export default HomePage;


File: frontend/src/pages\Lobby.jsx
// frontend/src/pages/Lobby.jsx
import React, { useState, useEffect } from "react";
import { Button, Typography, Paper } from "@mui/material";
import { useNavigate } from "react-router-dom";
import axios from "axios";
import { API_BASE_URL } from "../config/config";
import RoomCreationModal from "../components/RoomCreationModal";

function Lobby() {
  const navigate = useNavigate();
  const [username, setUsername] = useState("");
  const [rooms, setRooms] = useState([]);
  const [createRoomOpen, setCreateRoomOpen] = useState(false);

  useEffect(() => {
    const localUser = localStorage.getItem("username");
    if (localUser) {
      setUsername(localUser);
    }
    fetchRooms();
    const interval = setInterval(fetchRooms, 5000);
    return () => clearInterval(interval);
  }, []);

  const fetchRooms = async () => {
    try {
      // => GET http://127.0.0.1:8000/api/v1/rooms  (if API_BASE_URL is /api/v1)
      // or => GET http://127.0.0.1:8000/rooms     (if API_BASE_URL is /)
      const res = await axios.get(`${API_BASE_URL}/rooms`);
      setRooms(res.data.rooms || []);
    } catch (err) {
      console.error(err);
    }
  };

  const handleCreateCustomGame = () => {
    setCreateRoomOpen(true);
  };

  const handleRoomCreate = async (roomConfig) => {
    setCreateRoomOpen(false);
    try {
      const token = localStorage.getItem("token");
      // => POST http://127.0.0.1:8000/api/v1/rooms
      const res = await axios.post(
        `${API_BASE_URL}/rooms`,
        { ...roomConfig },
        { headers: { Authorization: `Bearer ${token}` } }
      );
      const newRoomId = res.data.room_id;
      navigate(`/room/${newRoomId}`);
    } catch (err) {
      alert("Failed to create room: " + err.message);
    }
  };

  // Placeholder
  const handleJoinPlaceholder = () => {
    const placeholderMatchId = "placeholder-match";
    navigate(`/game/${placeholderMatchId}`);
  };

  // Join room
  const handleJoinRoom = async (roomId) => {
    try {
      const token = localStorage.getItem("token");
      await axios.post(
        `${API_BASE_URL}/rooms/${roomId}/join`,
        {},
        { headers: { Authorization: `Bearer ${token}` } }
      );
      navigate(`/room/${roomId}`);
    } catch (err) {
      alert("Failed to join room: " + (err.response?.data?.detail || err.message));
    }
  };

  // Go to ReviewRoom
  const handleGoToReviewRoom = () => {
    navigate("/review");
  };

  return (
    <div style={{ padding: 20 }}>
      <Typography variant="h4" gutterBottom>
        Lobby
      </Typography>

      <Paper style={{ padding: 16, marginBottom: 16 }}>
        <Typography variant="h6" gutterBottom>
          Welcome, {username || "Guest"}!
        </Typography>
        <Typography>This is the game lobby. Here you can create or join matches.</Typography>
      </Paper>

      <div style={{ marginBottom: 16 }}>
        <Button
          variant="contained"
          color="primary"
          onClick={handleCreateCustomGame}
          style={{ marginRight: 8 }}
        >
          Create Custom Game
        </Button>
        <Button variant="contained" onClick={handleJoinPlaceholder} style={{ marginRight: 8 }}>
          Join Placeholder Game
        </Button>
        <Button variant="contained" onClick={handleGoToReviewRoom}>
          Go to Review Room
        </Button>
      </div>

      <Paper style={{ padding: 16 }}>
        <Typography variant="body1" gutterBottom>
          Active Rooms:
        </Typography>
        {rooms.map((room) => (
          <Paper key={room.room_id} style={{ padding: 8, margin: 8 }}>
            <Typography>Room ID: {room.room_id}</Typography>
            <Typography>ELO Range: {room.eloMin} - {room.eloMax}</Typography>
            <Typography>Players: {room.players.join(", ")}</Typography>
            <Typography>Started: {room.started ? "Yes" : "No"}</Typography>
            <Button
              variant="outlined"
              onClick={() => handleJoinRoom(room.room_id)}
              style={{ marginTop: 6 }}
            >
              Join
            </Button>
          </Paper>
        ))}
      </Paper>

      <RoomCreationModal
        open={createRoomOpen}
        onClose={() => setCreateRoomOpen(false)}
        onCreate={handleRoomCreate}
      />
    </div>
  );
}

export default Lobby;


File: frontend/src/pages\Profile.jsx
// frontend/src/pages/Profile.jsx

import React, { useState, useEffect } from "react";
import { Typography, Paper } from "@mui/material";
import { fetchUserInfo } from "../services/auth";

function Profile() {
  const [user, setUser] = useState({ username: "", email: "" });
  const [error, setError] = useState("");

  useEffect(() => {
    const loadProfile = async () => {
      try {
        const data = await fetchUserInfo();
        setUser({ username: data.username, email: data.email });
      } catch (err) {
        setError("Failed to load profile. Are you logged in?");
      }
    };
    loadProfile();
  }, []);

  return (
    <div style={{ padding: 20, display: "flex", justifyContent: "center" }}>
      <Paper style={{ width: 400, padding: 20 }}>
        <Typography variant="h5" gutterBottom>
          Profile
        </Typography>
        {error ? (
          <Typography color="error">{error}</Typography>
        ) : (
          <>
            <Typography>Username: {user.username}</Typography>
            <Typography>Email: {user.email}</Typography>
          </>
        )}
      </Paper>
    </div>
  );
}

export default Profile;


File: frontend/src/pages\Register.jsx
import React, { useState } from "react";

function Register() {
  const [username, setUsername] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [message, setMessage] = useState("");

  const handleSubmit = async (event) => {
    event.preventDefault();

    const response = await fetch("http://localhost:8000/register", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ username, email, password }),
    });

    if (response.ok) {
      setMessage("Registration successful! You can now log in.");
    } else {
      const errorData = await response.json();
      setMessage(`Registration failed: ${errorData.detail}`);
    }
  };

  return (
    <div>
      <h1>Register</h1>
      <form onSubmit={handleSubmit}>
        <div>
          <label>
            Username:
            <input
              type="text"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              required
            />
          </label>
        </div>
        <div>
          <label>
            Email:
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
            />
          </label>
        </div>
        <div>
          <label>
            Password:
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
          </label>
        </div>
        <button type="submit">Register</button>
      </form>
      {message && <p>{message}</p>}
    </div>
  );
}

export default Register;


File: frontend/src/services\auth.js
// authutils.js
export const login = async (username, password) => {
    const response = await fetch("http://127.0.0.1:8000/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, password }),
    });
    if (!response.ok) {
        throw new Error("Login failed");
    }
    const data = await response.json();
    localStorage.setItem("token", data.access_token);
};

export const fetchUserInfo = async () => {
    const token = localStorage.getItem("token");
    const response = await fetch("http://127.0.0.1:8000/users/me", {
        headers: { Authorization: `Bearer ${token}` },
    });
    if (!response.ok) {
        throw new Error("Failed to fetch user info");
    }
    return await response.json();
};

export const isAuthenticated = () => {
    return !!localStorage.getItem("token");
};

export const logout = () => {
    localStorage.removeItem("token");
};


File: backend/routers\matches.py
# backend/routers/matches.py

from fastapi import APIRouter, HTTPException
from backend.models import Move, CreateMatch, Player, Card, ResignRequest
from backend.services.go_game import GoGame
from backend.services.scoring import mark_dead_stone, final_scoring
import uuid
from sgfmill import sgf

router = APIRouter()

matches = {}  # match_id -> GoGame

dummy_players = [
    Player(player_id="AlphaGo", elo=3200, is_black=True, avatar_url=""),
    Player(player_id="Lee Sedol", elo=2800, is_black=False, avatar_url=""),
]

dummy_cards_black = [
    Card(card_id="card01", name="Attack Boost", description="Increases territory by 2", cost=1),
    Card(card_id="card02", name="Ko Trick", description="Retake Ko immediately", cost=2),
]

dummy_cards_white = [
    Card(card_id="card03", name="Solid Defense", description="Adds 1 to your liberties", cost=1),
    Card(card_id="card04", name="Lightning Strike", description="Removes 1 opponent stone", cost=1),
]


@router.post("/matches")
def create_match(data: CreateMatch):
    match_id = str(uuid.uuid4())
    game = GoGame(board_size=data.board_size)
    matches[match_id] = game
    return {
        "match_id": match_id,
        "board_size": data.board_size,
        "board": game.board,
        "current_player": game.current_player,
        "passes": game.passes,
        "captured": game.captured,
        "history_length": len(game.history),
        "game_over": game.game_over,
        "winner": game.winner,
    }


@router.post("/matches/{match_id}/move")
def make_move(match_id: str, move: Move):
    if match_id not in matches:
        raise HTTPException(status_code=404, detail="Match not found")
    game = matches[match_id]
    if game.game_over:
        raise HTTPException(status_code=400, detail="Game is already over.")

    success, message = game.play_move(move.x, move.y)
    if not success:
        raise HTTPException(status_code=400, detail=message)
    return {
        "board": game.board,
        "current_player": game.current_player,
        "message": message,
        "passes": game.passes,
        "captured": game.captured,
        "history_length": len(game.history),
        "game_over": game.game_over,
        "winner": game.winner,
    }


@router.post("/matches/{match_id}/resign")
def resign_match(match_id: str, req: ResignRequest):
    if match_id not in matches:
        raise HTTPException(status_code=404, detail="Match not found")
    game = matches[match_id]
    success, message = game.resign(req.player)
    if not success:
        raise HTTPException(status_code=400, detail=message)
    return {
        "board": game.board,
        "winner": game.winner,
        "game_over": game.game_over,
        "message": message,
        "passes": game.passes,
        "captured": game.captured,
        "history_length": len(game.history),
    }


@router.get("/matches/{match_id}")
def get_match(match_id: str):
    if match_id not in matches:
        raise HTTPException(status_code=404, detail="Match not found")
    game = matches[match_id]
    return {
        "board": game.board,
        "current_player": game.current_player,
        "winner": game.winner,
        "game_over": game.game_over,
        "passes": game.passes,
        "captured": game.captured,
        "history_length": len(game.history),
    }


@router.get("/matches/{match_id}/players")
def get_match_players(match_id: str):
    if match_id not in matches:
        raise HTTPException(status_code=404, detail="Match not found")
    return {
        "players": dummy_players,
        "black_cards": dummy_cards_black,
        "white_cards": dummy_cards_white,
    }


@router.get("/matches/{match_id}/export_sgf")
def export_sgf(match_id: str):
    """
    修复上下镜像翻转:
    SGF 以(0,0)为左上, row递增向下. 
    前端: (x,y) x=从上到下, y=从左到右.
    这里将 row = x 替换为 row = (board_size - 1 - x) 以避免常见解析器上下反转.
    col = y 不变.
    """
    if match_id not in matches:
        raise HTTPException(status_code=404, detail="Match not found")
    game = matches[match_id]
    sz = game.board_size

    sgf_game = sgf.Sgf_game(size=sz)
    root_node = sgf_game.get_root()
    black_player_name = "AlphaGo"
    white_player_name = "Lee Sedol"
    root_node.set("PB", black_player_name)
    root_node.set("PW", white_player_name)
    if game.winner:
        root_node.set("RE", game.winner)
    root_node.set("KM", str(game.komi))

    if hasattr(game, "move_records"):
        for (color, x, y) in game.move_records:
            # 修正 row => board_size - 1 - x
            row = sz - 1 - x
            col = y
            c = "b" if color == "black" else "w"
            node = sgf_game.extend_main_sequence()
            node.set_move(c, (row, col))

    sgf_bytes = sgf_game.serialise()
    return {"sgf": sgf_bytes.decode("utf-8")}


@router.post("/matches/{match_id}/mark_dead_stone")
def mark_dead_stone_api(match_id: str, xy: dict):
    if match_id not in matches:
        raise HTTPException(status_code=404, detail="Match not found")
    game = matches[match_id]
    x = xy["x"]
    y = xy["y"]
    mark_dead_stone(game, x, y, game.current_player)
    scoring_data = {
        "dead_stones": list(game.dead_stones),
        "territory": [],  # 先返回空; 真正territory可在 final_scoring 里计算
        "blackScore": 0,
        "whiteScore": 0,
    }
    return {"scoring_data": scoring_data}


@router.post("/matches/{match_id}/confirm_scoring")
def confirm_scoring_api(match_id: str):
    if match_id not in matches:
        raise HTTPException(status_code=404, detail="Match not found")
    game = matches[match_id]
    black_score, white_score, winner = final_scoring(game)
    return {
        "final_scored": True,
        "black_score": black_score,
        "white_score": white_score,
        "winner": winner,
    }


File: backend/routers\rooms.py
# backend/routers/rooms.py
from fastapi import APIRouter, HTTPException
import uuid

router = APIRouter()

rooms = {}  # room_id -> { config..., players: [username], ready: {username: bool}, started: bool }

@router.get("/rooms")
def list_rooms():
    room_list = []
    for rid, rinfo in rooms.items():
        room_list.append({
            "room_id": rid,
            "eloMin": rinfo["eloMin"],
            "eloMax": rinfo["eloMax"],
            "players": rinfo["players"],
            "started": rinfo["started"],
        })
    return {"rooms": room_list}

@router.post("/rooms")
def create_room(data: dict):
    """
    data={
      "eloMin": int,
      "eloMax": int,
      "whoIsBlack": "creator"/"opponent"/"random",
      "timeRule": "absolute"/"byoyomi",
      "mainTime": 300,
      "byoYomiPeriods":3,
      "byoYomiTime":30,
      "boardSize":19,
      "handicap":0
    }
    """
    room_id = str(uuid.uuid4())
    rooms[room_id] = {
        "eloMin": data["eloMin"],
        "eloMax": data["eloMax"],
        "whoIsBlack": data["whoIsBlack"],
        "timeRule": data["timeRule"],
        "mainTime": data["mainTime"],
        "byoYomiPeriods": data["byoYomiPeriods"],
        "byoYomiTime": data["byoYomiTime"],
        "boardSize": data["boardSize"],
        "handicap": data["handicap"],
        "players": [],
        "ready": {},
        "started": False,
    }
    return {"room_id": room_id}

@router.post("/rooms/{room_id}/join")
def join_room(room_id: str, username: str = "dummy_user"):
    if room_id not in rooms:
        raise HTTPException(status_code=404, detail="Room not found")
    room = rooms[room_id]
    if room["started"]:
        raise HTTPException(status_code=400, detail="Room has started")

    if len(room["players"]) >= 2:
        raise HTTPException(status_code=400, detail="Room is full")

    if username in room["players"]:
        return {"joined": True}

    room["players"].append(username)
    room["ready"][username] = False
    return {"joined": True}

@router.post("/rooms/{room_id}/ready")
def ready_room(room_id: str, username: str = "dummy_user"):
    if room_id not in rooms:
        raise HTTPException(status_code=404, detail="Room not found")
    room = rooms[room_id]
    if username not in room["players"]:
        raise HTTPException(status_code=400, detail="You are not in the room")

    room["ready"][username] = True
    all_ready = all(v for v in room["ready"].values())
    if len(room["players"]) == 2 and all_ready and not room["started"]:
        # 在此创建真正的 match 并开始游戏
        room["started"] = True
        # 省略: createMatch logic
        return {"started": True, "match_id": "some-new-match-id"}
    return {"started": False}


File: backend/services\go_game.py
# backend/services/go_game.py
import hashlib
import copy

def finalize_game(match_id, game):
    # TODO: ELO计算/存储等
    pass

class GoGame:
    def __init__(self, board_size=19, komi=6.5):
        self.board_size = board_size
        self.komi = komi
        self.board = [[None for _ in range(board_size)] for _ in range(board_size)]
        self.history = []
        self.captured = {"black": 0, "white": 0}
        self.current_player = "black"
        self.passes = 0
        self.game_over = False
        self.winner = None

        # 新增
        self.dead_stones = set()  # (x, y)
        self.move_records = []    # [(color, x, y), ...]

    def is_on_board(self, x, y):
        return 0 <= x < self.board_size and 0 <= y < self.board_size

    def get_board_hash(self):
        board_string = ''.join(
            ''.join((cell[0] if cell else '.') for cell in row)
            for row in self.board
        )
        return hashlib.sha256(board_string.encode()).hexdigest()

    def count_liberties(self, x, y, visited=None):
        if visited is None:
            visited = set()
        if (x, y) in visited:
            return 0
        visited.add((x, y))
        player = self.board[x][y]
        liberties = 0
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = x + dx, y + dy
            if self.is_on_board(nx, ny):
                if self.board[nx][ny] is None:
                    liberties += 1
                elif self.board[nx][ny] == player:
                    liberties += self.count_liberties(nx, ny, visited)
        return liberties

    def get_group(self, x, y, visited=None):
        if visited is None:
            visited = set()
        group = []
        stack = [(x, y)]
        player = self.board[x][y]
        while stack:
            cx, cy = stack.pop()
            if (cx, cy) in visited:
                continue
            visited.add((cx, cy))
            group.append((cx, cy))
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nx, ny = cx + dx, cy + dy
                if self.is_on_board(nx, ny) and self.board[nx][ny] == player:
                    stack.append((nx, ny))
        return group

    def capture_stones(self, x, y, player, simulate=False):
        opponent = "white" if player == "black" else "black"
        captured_any = False
        to_capture = []

        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = x + dx, y + dy
            if self.is_on_board(nx, ny) and self.board[nx][ny] == opponent:
                if self.count_liberties(nx, ny) == 0:
                    group = self.get_group(nx, ny)
                    to_capture.extend(group)
                    captured_any = True

        if not simulate and captured_any:
            for cx, cy in to_capture:
                self.board[cx][cy] = None
            self.captured[player] += len(to_capture)

        return captured_any

    def is_valid_move(self, x, y, player):
        if not self.is_on_board(x, y):
            return False, "Move out of bounds"
        if self.board[x][y] is not None:
            return False, "Cell already occupied"

        self.board[x][y] = player
        if self.count_liberties(x, y) == 0:
            if not self.capture_stones(x, y, player, simulate=True):
                self.board[x][y] = None
                return False, "Suicide move"
        self.board[x][y] = None
        return True, ""

    def play_move(self, x, y):
        if self.game_over:
            return False, "Game is over."

        if x is None and y is None:
            self.passes += 1
            if self.passes >= 2:
                self.game_over = True
                self.winner = "Draw by consecutive passes"
                finalize_game("<some-match-id>", self)
            else:
                self.current_player = "white" if self.current_player == "black" else "black"
            return True, "Pass"

        valid, msg = self.is_valid_move(x, y, self.current_player)
        if not valid:
            return False, msg

        old_board = copy.deepcopy(self.board)
        old_captured = self.captured.copy()

        self.board[x][y] = self.current_player
        self.capture_stones(x, y, self.current_player)

        board_hash = self.get_board_hash()
        if board_hash in self.history:
            self.board = old_board
            self.captured = old_captured
            return False, "Ko detected"

        self.history.append(board_hash)
        self.move_records.append((self.current_player, x, y))

        self.current_player = "white" if self.current_player == "black" else "black"
        self.passes = 0
        return True, "Move accepted"

    def resign(self, player):
        if self.game_over:
            return False, "Game is already over."
        self.game_over = True
        opponent = "white" if player == "black" else "black"
        self.winner = f"{player} resigned, {opponent} wins"
        finalize_game("<some-match-id>", self)
        return True, self.winner


File: backend/services\scoring.py
# backend/services/scoring.py
def mark_dead_stone(game, x, y, current_player):
    """
    如果 (x,y) 是当前玩家颜色的棋子，则切换它是否标记为死子
    （简单示例：只允许标记自己颜色的子为死子。
     实际上也可能需要允许标记对方子的死活）
    """
    if game.board[x][y] != current_player:
        return
    pos = (x, y)
    if pos in game.dead_stones:
        game.dead_stones.remove(pos)
    else:
        game.dead_stones.add(pos)

def final_scoring(game):
    """
    基于 game.dead_stones, 做一个简单的中国规则计算。
    """
    size = game.board_size
    board_copy = []
    for r in range(size):
        board_copy.append(game.board[r][:])

    # 提走死子
    for (x, y) in game.dead_stones:
        board_copy[x][y] = None

    visited = set()
    black_territory = 0
    white_territory = 0

    def neighbors(r, c):
        for (dr, dc) in [(-1,0),(1,0),(0,-1),(0,1)]:
            nr, nc = r+dr, c+dc
            if 0 <= nr < size and 0 <= nc < size:
                yield nr, nc

    # flood fill 空交点
    for r in range(size):
        for c in range(size):
            if board_copy[r][c] is None and (r,c) not in visited:
                queue = [(r,c)]
                territory_points = []
                color_set = set()
                while queue:
                    rr, cc = queue.pop()
                    if (rr, cc) in visited:
                        continue
                    visited.add((rr, cc))
                    territory_points.append((rr, cc))
                    for nr, nc in neighbors(rr, cc):
                        if board_copy[nr][nc] is None and (nr,nc) not in visited:
                            queue.append((nr,nc))
                        elif board_copy[nr][nc] in ("black", "white"):
                            color_set.add(board_copy[nr][nc])

                if len(color_set) == 1:
                    if "black" in color_set:
                        black_territory += len(territory_points)
                    if "white" in color_set:
                        white_territory += len(territory_points)

    # 数活子的个数
    black_stones = 0
    white_stones = 0
    for r in range(size):
        for c in range(size):
            if board_copy[r][c] == "black":
                black_stones += 1
            elif board_copy[r][c] == "white":
                white_stones += 1

    black_score = black_territory + black_stones
    white_score = white_territory + white_stones + game.komi

    if black_score > white_score:
        winner = "Black"
    elif white_score > black_score:
        winner = "White"
    else:
        winner = "Draw"

    game.game_over = True
    game.winner = winner + " by scoring"
    return black_score, white_score, game.winner


